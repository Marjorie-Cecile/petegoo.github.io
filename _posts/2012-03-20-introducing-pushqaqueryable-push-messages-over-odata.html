---
layout: post
title: Introducing Pushqa–Queryable Push Messages over OData
categories:
- ODAta
- Pushqa
- Rx
tags:
- Linq
- oData
- Pushqa
- Rx
- SignalR
status: publish
type: post
redirect_from: /index.php/2012/03/20/introducing-pushqaqueryable-push-messages-over-odata/
published: true
meta:
  _edit_last: '1'
author:
  login: admin
  email: pete@petegoo.com
  display_name: PeteGoo
  first_name: Peter
  last_name: Goodman
---
<p><strong>Pushqa is a smarter pub/sub model, allowing the subscriber to use LINQ to declare the messages they want to receive.</strong></p>
<h3>Background</h3>
<p>LINQ has revolutionised the way we work with data in .Net, allowing us to compose and query data sources of all types. When Microsoft introduced <a href="http://www.odata.org" target="_blank">OData</a> it opened up the ability to query server resources using a simple URI syntax or LINQ if you are using a .Net client. This was great news for accessing data stores like SQL using Entity Framework, NHibernate etc over HTTP such that the data manipulation and querying happens on the server before being sent to the client. A kind of LINQ remoting if you like. </p>
<p>Then came Reactive Extensions (<a title="Ractive Extensions" href="http://msdn.microsoft.com/en-us/data/gg577609" target="_blank">Rx</a>), a LINQ implementation that instead of accessing data sources, allows querying and composition of future events or event streams to produce new event streams. Rx revolutionises the event concept in .Net and makes dealing with asynchrony so much easier. </p>
<h3>Introducing Pushqa</h3>
<p>Suppose then, that we could also use Rx LINQ or OData uri syntax to filter an event stream of push messages before they leave the source. A kind of smarter Pub/Sub that allows the subscriber to specify which messages they want to receive from the server in a more natural declarative style. This is the goal of Pushqa, to give subscribers power over their own subscriptions. </p>
<p>Imagine a log viewer client that can filter to only the error level messages that happen to a specific user. Or a client cache that listens to specific domain events in order to evict only the items it cares about from it’s cache when they change.</p>
<p>By combining Rx, SignalR and OData Pushqa is able to translate LINQ queries to OData compliant URI conventions. The uri is used to initiate a persistent connection to the server that will then filter the events exposed by an Rx event stream into tailored streams for each client.</p>
<p>e.g.</p>
<p>The following code</p>
<pre class="brush: csharp;">eventProvider.Stocks
    .Where(s =&gt; 
        s.Name == &quot;GOOG&quot; || 
        s.Name == &quot;MSFT&quot;)
    .AsObservable()
    .Subscribe(s =&gt; Console.WriteLine(“{0} – {1}”, s.Name, s.Price))</pre>
<p>results in the following OData query</p>
<pre>http://my.domain.com/Stocks/?filter=(Name eq 'GOOG') or (Name eq 'MSFT')</pre>
<p>and the following output</p>
<blockquote>
<p>MSFT - 24.11<br />
    <br />GOOG - 457.52</p>
<p>MSFT - 30.11</p>
<p>GOOG - 576.65</p>
<p></p>
<p>…</p>
</blockquote>
<p>The stock events generated by the source on the server will be filtered to only Google and Microsoft before being sent to the subscriber one at a time using HTTP long polling or similar HTTP based push messaging as provided by SignalR.</p>
<p>Fetch the early bits from <a title="Pushqa on GitHub" href="https://github.com/PeteGoo/Pushqa" target="_blank">GitHub</a>. Be warned these bits are early but hopefully the sample projects will give you some ideas. Samples include:</p>
<ul>
<li>Using Skip and Take to complete event streams. </li>
<li>A Process Viewer showing the server’s process information with live updates. </li>
<li>A Stock ticker. </li>
<li>WPF and Web examples. </li>
</ul>
